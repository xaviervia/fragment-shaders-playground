<!doctype html><html><head>

  <script src="js/player.js"></script>

  <script src="js/shader.js"></script>
  <script src="js/vertex-buffer-object.js"></script>
  <script src="js/uniform.js"></script>
  <script src="js/logger.js"></script>
  <script src="js/program.js"></script>
  <script src="js/main.js"></script>

  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <output class="output">
    <span id="output.resolution" class="output__resolution"></span>
    <span id="output.mouse" class="output__mouse"></span>
    <span id="output.time" class="output__time"></span>
  </output>

  <canvas id="canvas" class="canvas" width="1000px" height="1000px"></canvas>

  <script id="script.fragment" type="text/glsl">



#ifdef GL_ES
precision mediump float;
#endif



// ===============================================================
//  UNIFORMS
// ===============================================================
uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;



// ===============================================================
//  NORMALIZERS
// ===============================================================
vec4 self() { return gl_FragCoord; }


vec2 normalizedSelf() { return self().xy / resolution; }


vec2 middleSelf() {
  return vec2(
    self().x - resolution.x / 2.0,
    self().y - resolution.y / 2.0
  );
}


vec2 middleMouse() {
  return vec2(
    mouse.x - resolution.x / 2.0,
    mouse.y - resolution.y / 2.0
  );
}


vec2 normalizedMouse() { return mouse * 2.0 / resolution; }



// ===============================================================
//  DETECTION
// ===============================================================
bool left() {
  return middleSelf().x <= 0.0;
}


bool right() {
  return middleSelf().x > 0.0;
}


bool bottom() {
  return middleSelf().y <= 0.0;
}


bool top() {
  return middleSelf().y > 0.0;
}



// ===============================================================
//  NOISE
// ===============================================================
float noise(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


float noise(vec2 co, float seed) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * seed);
}


float normalNoise(vec2 coordinates, float factor) {
  float noise = noise(coordinates);
  return ((noise - noise / 2.0) * 2.0) / factor;
}


float normalNoise(vec2 coordinates, float factor, float seed) {
  float noise = noise(coordinates, seed);
  return ((noise - noise / 2.0) * 2.0) / factor;
}



// ===============================================================
//  COLORS
// ===============================================================
vec3 background() {
  return vec3(0.92, 0.9, 0.8) + normalNoise(middleSelf(), 6.0);
}


vec3 middleground() {
  return vec3(0.6, 0.6, 0.6) + normalNoise(middleSelf(), 2.0, time);
}


vec3 foreground(float intensity) {
  return vec3(1.0 - intensity) + normalNoise(middleSelf(), 6.0);
}



// ===============================================================
//  DRAWERS
// ===============================================================
bool isForeground(vec3 tracing) {
  for (float indexX = -1.0; indexX < 2.0; indexX += 1.0)
    for (float indexY = -1.0; indexY < 2.0; indexY += 1.0)
      if (middleSelf() + vec2(indexX, indexY) == tracing.xy)
        return true;

  return false;
}


bool isMiddleground(vec3 tracing) {
  for (float indexX = -3.0; indexX < 4.0; indexX += 1.0)
    for (float indexY = -3.0; indexY < 4.0; indexY += 1.0)
      if (middleSelf().xy + vec2(indexX, indexY) == tracing.xy)
        return true;

  return false;
}


vec3 draw(vec3 tracing) {
  if (isForeground(tracing))         return foreground(tracing.z);
  else if (isMiddleground(tracing))  return middleground();

  return background();
}



// ===============================================================
// MAIN
// ===============================================================
vec3 point() {
  return vec3(middleSelf().x, -middleSelf().x, 0.7);
}

vec3 circle(float radius) {

  float xSquared = pow(radius, 2.0) - pow(middleSelf().y, 2.0);
  float ySquared = pow(radius, 2.0) - pow(middleSelf().x, 2.0);
  float x = sqrt(xSquared);
  float y = sqrt(ySquared);

  if (left()) {
    x = -x;
  }

  if (bottom()) {
    y = -y;
  }

  return vec3(
    floor(x) + 0.5,
    floor(y) + 0.5,
    0.8
  );
}



// ===============================================================
// MAIN
// ===============================================================
void main() {
	gl_FragColor = vec4( draw(circle(200.0)), 1.0 );
}

  </script>


  <script id="script.vertex" type="text/glsl">
precision mediump float;
uniform vec2 u_resolution;
uniform float u_time;
attribute vec2 a_position;
attribute vec2 a_texcoord;
varying vec2 v_texcoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
  v_texcoord = a_texcoord;
}
  </script>
</body></html>
